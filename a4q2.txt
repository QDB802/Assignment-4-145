Name: Ken Duff
NSID: qdb802
Student#: 11318955
CMPT 145
Instructor: Lauresa Stilling

a)
def search(L, target):
    # L is a list
    found = False                           O(1)
    i = 0                                   O(1)
    while i < len(L) and not found:         O(N)
        if L[i] == target:                  O(1)
            found = True                    O(1)
        i += 1                              O(1)
    return found                            O(1)

The time complexity for this program is O(N) or (O(L) if we use the function parameter. This is because for a worst-case
scenario list of N-Size, where the target is the last value, the program will cycle through the N-sized list, and
since there are no secondary lists to go through, the complexity is related to N, or in the case of parameters; L.

b)
def repeat (x):
    # x is an integer
    for i in range (1000):   O(1)
        print (x)            O(1)

The time complexity for this program is O(1). The program always iterates exactly 1000 times, no matter what integer
is input into the program, it always runs through a constant amount of times.

c)
def compare (a, b):
    # a and b are integers
    if a > b:           O(1)
        return 1        O(1)
    elif b > a:         O(1)
        return -1       O(1)
    else:               O(1)
        return 0        O(1)

The time complexity for this program is O(1). The program will always perform a set amount of operations no matter what
the input is into the program. So the complexity only depends on the amount if/else comparisons made.

d)
def is_prime ( a ):
    # a is an integer
    if a == 1:                  O(1)
        return False            O(1)
    elif a == 2 or a == 3:      O(1)
        return True             O(1)
    result = True               O(1)
    for i in range (2 , a //2): O(N)
        if a % i == 0:          O(1)
            result = False      O(1)
    return True                 O(1)

The time complexity for this program is O(N) or O(a) for function parameters. The program in its worst case scenario
will have to iterate through the range of numbers.

e)
def find_triples(L):
    # L is a list
    if len (L) == 0:                 O(1)
        return 0                     O(1)
    L = sorted(L)                    O(N log N)
    triples = 0                      O(1)
    repeats = 1                      O(1)
    prev = L[0]                      O(1)
    for i in range (1, len(L)):      O(N)
        cur = L[i]                   O(1)
        if cur != prev :             O(1)
            repeats = 1              O(1)
        else:                        O(1)
            repeats += 1             O(1)
            if repeats == 3:         O(1)
                triples += 1         O(1)
        prev = cur                   O(1)

    return triples                   O(1)

The program has the time complexity O(N log N)/O(L log L). This is because of the use of the
python sorted() function, which naturally has the time complexity O(N log N). But, with the addition of the
range function, it adds a range function with notation O(N). However, since Big-O notation only uses
the largest N, the time complexity for this function is O(L log L).

f)
def interleave (L1, L2):
    # L1 and L2 are lists
    i = 0                              O(1)
    result = []                        O(1)
    while i < min(len(L1), len(L2)):   O()
        result.append (L1[i])          O(1)
        result.append (L2[i])          O(1)
        i += 1                         O(1)
    if len(L1) > len(L2):              O(1)
        longer = L1                    O(1)
    else:                              O(1)
        longer = L2                    O(1)
    for j in range(i, len(longer)):    O()
        result.append(longer[j])       O(1)
    return result                      O(1)

The program has the time complexity O().